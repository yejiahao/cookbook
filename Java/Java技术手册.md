### 2.4.7 位运算符和位移运算符
- 左移（<<）
<< 运算符把左侧操作数的每一位向左移动右侧操作数指定的位数。
左侧操作数的高位被丢掉，右边缺少的位补零。
整数向左移 n 位，相当于乘于 2n。
例如：如果左侧操作数是 long 类型，右侧操作数应该介于 0 和 63 之间。
```java
10 << 1 // 00001010 << 1 = 00010100 = 20 = 10*2
7 << 3 // 00000111 << 3 = 00111000 = 56 = 7*8
-1 << 2 // 0xFFFFFFFF << 2 = 0xFFFFFFFC = -4 = -1*4
```
如果左侧操作数是 int 类型，右侧操作数应该介于 0 和 31 之间。
- 带符号右移（>>）
\>> 运算符把左侧操作数的每一位向右移动右侧操作数指定的位数。
左侧操作符的低位被移除，移入的高位和原来的最高位一样。
也就是说，如果左侧操作数是正数，移入的高位是 0；如果左侧操作数是负数，移入的高位是 1。
这种技术叫高位补符号，作用是保留左侧操作数的符号。
例如：
```java
10 >> 1 // 00001010 >> 1 = 00000101 = 5 = 10/2
27 >> 3 // 00011011 >> 3 = 00000011 = 3 = 27/8
-50 >> 2 // 11001110 >> 2 = 11110011 = -13 != -50/4
```
如果左侧操作数是正数，右侧操作数是 n，>> 运算符的计算结果相当于整数除以 2n。
- 不带符号右移（>>>）
这个运算符和 >> 类似，但是不管左侧操作数的符号是什么，高位总是移入 0。
这种技术叫高位补零。
左侧操作数是无符号的数字时才适用这个运算符（可是 Java 的整数类型都带符号）。
下面是一些例子：
```java
0xff >>> 4 // 11111111 >>> 4 = 00001111 = 15 = 255/16
-50 >>> 2 // 0xFFFFFFCE >>> 2 = 0x3FFFFFF3 = 1073741811
```

### 2.5.4 标注语句
标注语句就是有名称的语句。
命名方法是，在语句前加上一个标识符和一个冒号。
 break 和 continue 语句会用到标注。
例如：
```java
rowLoop: for(int r = 0; r < rows.length; r++) { // 一个标注循环
 colLoop: for(int c = 0; c < columns.length; c++) { // 另一个
 break rowLoop; // 使用标注
 }
}
```

### 3.4.5 遮盖超类的字段
假如有三个类 A、B 和 C，它们都定义了一个名为 x 的字段，而且 C 是 B 的子类，B 是 A 的子类。
那么，在 C 类的方法中可以按照下面的方式引用这些不同的字段：
```java
x // C类的x字段
this.x // C类的x字段
super.x // B类的x字段
((B)this).x // B类的x字段
((A)this).x // A类的x字段
super.super.x // 非法，不能这样引用A类的x字段
```
目前为止，讨论的都是实例字段。
类字段也能被遮盖。
引用被遮盖的类字段中的值，可以使用相同的 super 句法，但没必要这么做，因为始终可以把类名放在类字段前引用这个字段。
假如 PlaneCircle 的实现方觉得 Circle.PI 字段没有提供足够的小数位，那么他可以自己定义 PI 字段：
```java
public static final double PI = 3.14159265358979323846;
```
现在，PlaneCircle 类中的代码可以通过表达式 PI 或 PlaneCircle.PI 使用这个更精确的值，还可以使用表达式 super.PI 和 Circle.PI 引用精度不高的旧值。
不过，PlaneCircle 继承的 area() 和 circumference() 方法是在 Circle 类中定义的，所以，就算 Circle.PI 被 PlaneCircle.PI 遮盖了，这两个方法还是会使用 Circle.PI 的值。

### 8.1.7 数组和辅助方法
在 Java 中，数组可以视作对象，也可以按照对象的方法处理。
假如有个对象 o，可以使用类似下面的代码判断这个对象是否为数组。
如果是，则判断是什么类型的数组：
```java
Class type = o.getClass();
if (type.isArray()) {
 Class elementType = type.getComponentType();
}
```

### 10.5.1 HTTP
HTTP 定义了多个“请求方法”，客户端使用这些方法操作远程资源。
这些方法是：GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE 各个方法的用法稍微不同，例如：
- GET 只能用于取回文档，不能执行任何副作用；
- HEAD 和 GET 作用一样，但是不返回主体——如果程序只想检查 URL 对应的网页是否有变化，可以使用 HEAD；
- 如果想把数据发送给服务器处理，要使用 POST。
```java
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
conn.setInstanceFollowRedirects(false);
```
注意，请求参数要在请求的主体中发送，而且发送前要编码。
我们还要禁止跟踪 HTTP 重定向，手动处理服务器返回的每个重定向响应。
这是因为 HttpURLConnection 类有个缺陷，不能正确处理 POST 请求的重定向响应。

### 10.5.3 IP
在 Java 中可以创建基于单个 IP 数据包（首部除了可以指定使用 TCP 协议，还可以指定使用 UDP2 协议）的数据报服务，不过，除了延迟非常低的应用之外很少需要这么做。
 Java 使用 DatagramSocket 类实现这种功能，不过很少有开发者需要深入到网络协议栈的这一层。

### 13.2 VisualVM
在操作系统监视器实现的锁（即同步块）上竞争的线程放入 BLOCKED 状态，在VisualVM 中使用红色表示。
锁定的 java.util.concurrent 锁对象把线程放入 WAITING 状态（在 Visual VM 中使用黄色表示）。
这是因为 java.util.concurrent 实现的锁完全在用户空间中，不涉及操作系统。
 JVisualVM 提供了插件系统，下载并安装额外的插件就能扩展这个框架的功能。
我们推荐一定要安装 MBeans 插件（如图 13-6）和 VisualGC 插件（下面会介绍，如图 13-7）。
为了兼容以前的 Java 版本，通常还会安装 JConsole 插件。